# 03. Variable and Constant

## 3.1 식별자

- 식별자는 변수나 함수의 이름이다.
- 식별자는 값이 아니라 값이 저장된 메모리 주소를 기억한다.



### 식별자 네이밍 컨밴션

- Javascript 식별자는 문자, 밑줄, 달러 기호로 시작할 수 있다.
- Javascript 식별자는 대소문자를 구분한다.
- Javascript 식별자는 문자, 숫자, 밑줄을 포함할 수 있다.
- Javascript 식별자에는 유니코드 문자, 유니코드 이스케이프 시퀀스를 사용할 수 있다.
- Javascript 식별자에는 공백을 포함할 수 없다.
- Javscript 식별자에는 예약어를 사용할 수 없다. (strict mode)



## 3.2 변수

**변수(variable)**은 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

선언되지 않은 식별자에 접근하거나 초기화 단계를 거치지 않은 변수에 접근하면 `ReferenceError` 예외가 발생하므로, 변수를 사용하려면 반드시 변수를 선언해야한다.

```js
console.log(a);
// Uncaught ReferenceError: a is not defined
```



### 변수 선언하기

>자바스크립트 엔진은 변수 선언을 2단계로 수행한다.
>
>1. **선언 단계**: 변수 이름을 스코프(실행 환경의 렉시컬 환경(lexical environment))에 등록하여 자바스크립트 엔진에게 변수의 존재를 알린다.
>2. **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당하여 초기화한다.



#### 선언 단계

변수를 선언하는 방법은 다음과 같다.

- `var` 키워드로 선언하기
- `let` 키워드로 선언하기
- `const` 키워드로 선언하기
- 키워드 없이 선언하기



##### `var` 키워드로 선언하기

```javascript
var x;
```

**`var` 키워드**로 선언된 변수는 **함수 레벨 스코프(function-level scope)**를 가진다. 즉, 함수에 지역적인 변수와 전역 변수를 선언하는데 사용한다.



##### `let` 키워드로 선언하기

```js
let y;
```

ES6에 도입된 **`let` 키워드**로 선언된 변수는 **블록 레벨 스코프(block-level scope)**를 가진다. 즉, 코드 블록에 지역적인 변수를 선언하는데 사용한다.



##### `const` 키워드로 선언하기

```js
const z = 1;
```

ES6에 도입된 **`const` 키워드**로 선언된 변수는 **블록 레벨 스코프**를 가진다. `let`과 달리 상수를 만드는 데 사용한다. [3.3 상수](#33-상수)를 참고한다.



##### 키워드를 사용하지 않고 선언하기

```js
i;	// ReferenceError: i is not defined
```

키워드 없이 선언만 하면 선언되지 않은 전역 변수를 만든다.

```js
i = 3;
```

선언하지 않은 변수에 값을 할당하는 것을 암묵적 전역이라 한다.



#### 초기화 단계

```js
let a;
console.log(a);	// undefined
```

변수는 초기화 단계에서 확보한 메모리 공간에 `undefined` 값을 갖는다. 따라서 변수를 할당하지 않는다면 변수는 `undefined` 값을 반환한다.

한편, `var` 키워드로 선언한 변수와 `let`/`const`로 선언한 변수의 초기화 단계가 실행되는 시점이 다르다. [변수 선언의 실행 시점](#변수-선언의-실행-시점)과 [변수 호이스팅](#변수-호이스팅)을 참고한다.



#### 변수 여러 개를 선언하기

```javascript
let name, age;
```



### 변수 할당하기

변수에 값을 할당하는 방법은 두 가지가 있다.

- 변수를 선언한 후 할당하기
- 선언과 동시에 할당하기(단축 표현)



#### 변수를 선언한 후 할당하기

선언한 변수에 값을 할당하려면 할당 연산자 `=`를 사용한다.

```js
let a;
a = 1;
```

`a`의 선언은 호이스팅되었고 선언 단계를 런타임 이전에 실행한다. 이후 런타임에서 `a`의 선언문 곧 `let a`에 도달하면 초기화 단계가 실행되고 그 다음 줄이 실행되며 `a`에는 최종적으로 `1`이 담긴다.



#### 선언과 동시에 할당하기

선언과 동시에 할당할 수 있다. 

```js
let a = 1;
```

이 단축 표현을 사용해도 자바스크립트 엔진은 [변수를 선언한 후 할당하기](#변수를-선언한-후-할당하기)처럼 두 개의 문으로 나누어 실행한다. 즉 두 소스 코드는 동일하게 변수를 선언한 후 할당하기처럼 동작한다.



#### 변수 여러 개 선언하고 할당하기

```javascript
let name = 'umi', age = 1;
```



#### 변수의 값을 다른 변수에 할당하기

자바스크립트는 변수를 다른 변수에 할당하면 **원본의 값을 복사하여 전달**한다. 이때 두 변수는 **서로 다른 메모리 공간을 가질뿐 같은 값을 저장**하게 된다.

```js
let a = 1;
let b;
b = a;
console.log(a);	// 1
console.log(b);	// 1
```

이런 평가 전략을 **값에 의한 전달(pass by value)**라고 한다. [pass by value](#34-pass-by-value)를 참고한다.



### 변수 재할당하기

이미 선언하고 할당된 변수에 다른 값을 재할당할 수 있다. 할당문을 사용하면 된다.

```js
let a = 1;
a = 2;
```

이때 최초로 `1`을 할당할 때 확보한 메모리 공간에 들어있던 값 `1`을 지우고 `2`를 넣는 것이 아니라 새롭게 메모리 공간을 확보하여 값 `2`를 넣는다.



### 변수의 스코프

- 변수의 범위는 함수를 기준으로 나뉜다.
  - 전역 변수: 함수의 바깥에 선언된 변수.
  - 지역 변수: 함수의 내부에 선언된 변수. 함수 내에서만 사용할 수 있다.
- ES6 이전에는 블록 범위가 존재하지 않았다. `var`로 선언된 변수는 해당 변수가 선언된 함수나 전역 범위에 지역적이다. 즉, 함수 레벨 변수만 선언할 수 있었다.

```javascript
if (true) {
    var x = 5;
}
console.log(x);	// 5
```

이 경우 `x`의 범위는  `if`문 블록이 아니라 `x`가 선언된 함수 혹은 전역 문맥이다.

- ES6에 도입된 `let`과 `const`로 블록 레벨 변수를 선언할 수 있다.

```javascript
if (true) {
    let y = 5;
}
console.log(y);	// ReferenceError 발생
```

[Scope](https://github.com/leegwae/study-javascript/blob/main/Scope.md)를 참고한다.



### 변수 선언의 실행 시점

```js
console.log(a);		// undefined

var a = 1;

console.log(a);		// 1
```

선언되지 않은 변수를 참조하는 것은 `ReferenceError`를 발생시킨다. 그러나 `라인 1`에서 그 전에 선언되지 않은 변수 `a`를 참조함에도 `ReferenceError`를 일으키지 않는다. 이는 자바스크립트에서 **변수 선언은 스크립트가 한 줄씩 실행되는 런타임(runtime) 이전에 실행되기 때문**이다. 즉 `라인 1`이 실행되는 런타임 이전에 변수 `a`에 대하여 선언 단계가 실행되었기 때문이다. 이때 변수 선언이 *상단으로 끌어올려졌다*고 하며, **변수 호이스팅(variable hoisting)**이라고 한다.



### 변수 호이스팅

#### 키워드 `var`로 선언한 경우

[변수 할당하기](#변수-할당하기)에서 볼 수 있듯이, 위 코드에서 `라인 3`의 할당문 `var a = 1;`은 아래처럼 두 개의 문으로 나눌 수 있다.

```js
console.log(a);		// undefined

var a;
a = 1;

console.log(a);		// 1
```

이 코드에서 `라인 3`의 변수 선언문인 `var a;`만 *상단으로 끌어올려져*, 런타임 이전에 식별자 `a`에 대해 선언 단계와 초기화 단계가 실행되어 `undefined`로 초기화된다.

```js
var a;	// 런타임 이전에 선언 단계, 초기화 단계 실행
console.log(a);	// undefined

a = 1;	// 1을 할당

console.log(a);	// 1
```



#### 키워드 `let`, `const`로 선언한 경우

```js
console.log(a);		// ReferenceError

let a;
a = 1;

console.log(a);
```

`let`과 `const`로 선언된 변수 선언문 역시 *상단으로 끌어올려진다*. 그러나 런타임 이전에 식별자 `a`에 대해 선언 단계만 실행된다. 따라서 초기화 단계가 실행되지 않아 `undefined`로 초기화되지 않고, `ReferenceError`를 발생시킨다.



#### 일시적 사각지대

`var` 키워드로 선언된 변수는 호이스팅되어 런타임 이전에 선언 단계와 초기화 단계가 실행된다. 따라서 선언 이전에 참조한 변수는 `undefined`를 반환한다.

```js
// 호이스팅되어 런타임 이전에 선언 단계, 초기화 단계 실행
console.log(a);	// undefined
var a = 1;	// 할당
```

`let`이나 `const` 키워드로 선언된 변수는 호이스팅되어 런타임 이전에 선언 단계를 실행한다. 초기화 단계는 변수 선언문에서 실행된다.

```js
// 호이스팅 되어 런타임 이전에 선언 단계 실행
console.log(a);	// ReferenceError: a is not defined
let a = 1;	// 초기화 단계 실행 후 할당
```

이처럼 변수를 스코프의 시작 지점부터 초기화 단계의 시작 지점까지 참조할 수 없는 구간을 **일시적 사각지대**(TDZ; temporal dead zone)이라고 한다.

[Hoisting](https://github.com/leegwae/study-javascript/blob/main/Hoisting.md)을 참고한다.



### 전역 변수

`var`로 선언한 전역 변수와 키워드 없이 선언한 변수(암묵적 전역)은 **전역 객체**(global object)의 프로퍼티가 된다. 브라우저 환경에서 전역 객체를 가리키는 식별자는 `window`이지만 전역 객체의 프로퍼티를 참조할 때에는 `window`를 생략할 수 있다.

```js
var a = 1;
window.a;	// 1
a;	// 1
```

[전역 객체](https://github.com/leegwae/study-javascript/blob/main/11.%20Objects.md#117-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4)를 참고한다.



## 3.3 상수

**상수(constant)**는 최초로 값이 할당된 이후 그 값이 변경할 수 없다.

- (1) 코드가 실행되기 전 그 값이 정해진 상수
- (2) 런타임 과정에서 계산되나 할당 이후 값이 변하지 않는 상수



### 상수의 선언과 할당

- ES6에 도입된 `const` 키워드로 읽기 전용 상수를 선언할 수 있다.

```javascript
const PI = 3.141592
```

- 같은 범위에 있는 함수나 변수와 동일한 이름으로 선언할 수 없다.
- 값으로 초기화 이후 런타임에 대입을 통해 재할당을 하거나 재선언할 수 없다. `TypeError`를 발생시킨다.

```js
const a = 1;
a = 2;
// TypeError: Assignment to constant variable.
```

- 그러나 <u>상수에 할당된 객체의 프로퍼티, 배열의 내용</u>은 보호되지 않는다: **상수 객체의 값은 변하지 않지만 그 내용은 수정할 수 있다. ** 상수는 재할당이 되지 않을 뿐 값의 불변을 의미하지는 않기 때문이다.

```javascript
/* 객체의 프로퍼티 */
const MY_OBJECT = { 'name': 'lana' };
MY_OBJECT.name = 'umi';

/* 배열의 내용 */
const MY_ARRAY = [ 1, 2, 3 ];
MY_ARRAY.push(4);
```



## 네이밍 컨밴션

- 변수나 함수는 대개 카멜 케이스를 사용한다. 예) `getClassName`
- 생성자 함수, 클래스에는 파스칼 케이스를 사용한다. 예) `MyClass`
- 상수는 대개 대문자와 밑줄로 구성한다. 예) `MAX_SIZE`
  - 런타임에 계산되는 경우는 변수와 동일하게 짓는다.



## let, var, const의 비교

- `var`: 함수 레벨 지역 변수 혹은 전역 변수를 선언한다.
- `let`: 블록 레벨 지역 변수를 선언한다.
- `const`: 블록 레벨 읽기 전용 상수를 선언한다.



| 키워드  | 재선언 | 재할당 |
| ------- | ------ | ------ |
| `var`   | o      | o      |
| `let`   | x      | o      |
| `const` | x      | x      |

이때 재선언이란 같은 스코프 내에서의 재선언을 의미한다. 스코프가 다르다면 이름이 같은 변수를 선언할 수 있다.

```js
const a = 1;	// 전역
{
    const a = 1;	// 코드 블록에 지역적
}
```



## 3.4 Pass by Value

자바스크립트는 평가 전략으로 **값에 의한 전달(pass by value)**을 사용한다. 함수에 인자를 넘기는 관점에서는  **값에 의한 호출(call by value)**이라고 한다. 값에 의한 전달에서는 변수를 다른 변수에 할당할 때 **원본 변수의 값을 복사하여 전달**한다. 엄밀히 하면, 값에 의한 전달은 메모리 주소를 전달하고 전달받은 메모리 주소에 접근하여 값을 참조한다.



### 원시 값 전달하기

- 원시 값을 변수에 할당하면 확보된 메모리 공간에는 실제 **원시 값**이 저장된다.

```js
let a = 1;
```

변수 `a`에 원시 값 `1`을 할당할 때, 확보한 메모리 공간에는 실제로 `1`이 들어있다.

- 그렇다면 원시 값이 할당된 변수를 다른 변수에 할당하면 값에 의한 전달에 의해 원시 값이 복사되어 전달된다.

```js
let b = a;
console.log(a === b);	// true
```

변수 `b`에는 변수 `a`의 값 `1`이 복사되어 전달되었다. 즉, 변수 `b`의 메모리 공간에 변수 `a`의 메모리 공간에서 복사한 값 `1`이 저장되었다. 둘은 별개의 메모리 공간일뿐 동일한 값이 저장되어있다. 따라서, `b`의 값을 수정해도 `a`에는 변화가 없다.

````js
b = 2;
console.log(a);	// 1
console.log(b);	// 2
````



### 객체 전달하기

- 객체를 변수에 할당하면 확보된 메모리 공간에는 **참조 값**이 저장된다. 참조 값이란, 객체가 저장된 메모리 공간의 메모리 주소이다. 즉 원시 값이 그대로 저장되었던 것과 달리 실제 객체가 저장된 메모리는 따로 있고 변수에는 그 메모리의 주소(참조)가 저장되는 것이다.

```js
let foo = { name: 'lana' };
```

변수 `foo`에 객체 `{ name: 'lana' }`를 할당할 때, 확보한 메모리 공간에는 `{ name: 'lana' }`이 저장된 메모리 공간의 주소 곧 객체에 대한 참조 값이 들어있다.

- 그렇다면 객체가 할당된 변수를 다른 변수에 할당하면 값에 의한 전달에 의해 참조 값이 복사되어 전달된다.

```js
let bar = foo;
console.log(foo === bar);	// true
```

변수 `bar`에는 변수 `foo`의 객체 참조 값이 복사되어 전달되었다. 즉, 변수 `bar`의 메모리 공간에 변수 `foo`의 메모리 공간에서 복사한 참조 값이 저장되었다. 둘은 별개의 메모리 공간일뿐 동일한 값이 저장되어있다. 따라서 `bar`의 값을 수정해도 `foo`에는 변화가 없다.

```js
bar = {};
console.log(b);	// {}
console.log(a === b);	// false
```

`bar`에 `{}`를 할당하여, `bar`의 메모리 공간에는 이제 `{}`이 저장된 메모리 공간에 대한 참조가 들어있다.

- 단, 프로퍼티에 접근하면 원본 변수에도 영향을 끼친다.

```js
let foo = { name: 'lana' };
let bar = foo;
console.log(foo.name);	// 'lana'
console.log(bar.name);	// 'lana'
console.log(foo === bar);	// true
```

`foo`를 `bar`에 할당했다. `foo`와 `bar`은 동일한 객체에 대한 참조 값을 가진다. 즉, `foo`와 `bar`은 동일한 객체를 참조한다.

```js
bar.name = 'lux';
console.log(foo.name);	// 'lux'
console.log(bar.name);	// 'lux'
console.log(foo === bar);	// true
```

`bar.name`을 통해 프로퍼티에 접근하여 값을 `'lux'`로 수정했다. 프로퍼티에 접근하는 것은 변수가 참조하고 있는 객체에 직접 접근하는 것이다. 따라서 `bar`이 참조하고 있는 객체를 수정했으므로 동일한 객체를 참조하고 있는 `foo`의 `name` 프로퍼티도 `'lux'`로 출력되는 것이다.

`foo.name`을 통해 프로퍼티에 접근하여 값을 `'lux'`로 수정했어도 동일한 결과가 출력되었을 것이다.

```js
bar = { name: 'lux' };
console.log(foo.name);	// 'lana'
console.log(bar.name);	// 'lux'
console.log(foo === bar);	// false
```

만약 `bar.name`을 수정하지 않고 `bar`에 새롭게 객체를 할당했다면, 자바스크립트 엔진은 객체 리터럴을 평가하여 새로운 메모리 공간을 할당하고 그에 대한 참조를 `bar`의 변수가 확보한 메모리 공간에 저장했을 것이다.이렇게 하면 `foo`와 `bar`은 더이상 같은 객체를 참조하지 않으므로 일치 비교 연산에서 `false`를 반환한다.



### pass by sharing

자바스크립트는 값에 의한 전달을 사용하므로 변수를 다른 변수에 할당하면 원본 변수의 값이 복사되어 전달된다. 한편, 원시 값을 변수에 할당하면 확보한 메모리 공간에는 해당 원시 값이 저장된다. 반면에 객체를 변수에 할당하면 확보한 메모리 공간에는 객체에 대한 참조 값이 저장된다.

변수에 원시 값을 할당했든 객체를 할당했든 값에 의한 전달을 사용한다는 점에서는 동일하다. 다만 *값을 수정*한다는 관점에서, 원시 값의 경우 원본 변수는 영향을 받지 않지만 객체의 경우 원본 변수가 영향을 받는다는 차이가 있다. 따라서 의미를 더 명확히 하기 위해 **공유에 의한 전달(pass by sharing)** 혹은 **공유에 의한 호출(call by sharing)**이라고도 한다.

변수를 변수에 할당하는 관점이 아니라 인자를 함수에 전달할 때 함수의 매개변수에 인자가 복사되는 관점에서 살펴보려면 [Call by Sharing](https://github.com/leegwae/study-javascript/blob/main/Call%20by%20Sharing.md)을 참고한다.

