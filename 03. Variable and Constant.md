# 03. Variable and Constant

## 3.1 변수

**변수(variable)**은 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다.

```javascript
var a = 1;
```

위의 경우 `a`는 변수 이름이며, `1`은 변수 값이다.

### 식별자로서의 변수 이름

변수 이름은 메모리 주소를 식별하는 고유한 이름으로서 **식별자(identifier)**라고 한다. 식별자와 메모리 주소의 매핑 정보는 메모리에 저장된다.

선언되지 않은 식별자에 접근하거나 초기화 단계를 거치지 않은 변수에 접근하면 `ReferenceError` 예외가 발생하므로, 변수를 사용하려면 반드시 변수를 선언해야한다.

```js
console.log(a);
// Uncaught ReferenceError: a is not defined
```



### 변수 선언하기

**변수 선언(variable declaration)**은 메모리 공간을 확보하고 그 주소와 식별자를 네임 바인딩(name binding)하여 값을 저장할 수 있게 준비하는 것이다.

**자바스크립트 엔진은 변수 선언을 2단계로 나누어 수행한다.**

1. **선언 단계**: 변수 이름을 실행 컨텍스트(execution context)에 등록하여 자바스크립트 엔진에게 변수의 존재를 알린다.

2. **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당하여 초기화한다.

    초기화(initialization)란 변수에 최초로 값을 할당하는 것이다.

선언 단계는 런타임 이전에 실행되나, 초기화 단계는 변수 선언 방법에 따라 런타임 이후에 실행되기도 한다. [변수 선언의 실행 시점](#변수-선언의-실행-시점)과 [변수 호이스팅](#변수-호이스팅)을 참고한다.



변수를 선언하는 방법은 다음과 같다.

- `var` 키워드로 선언하기
- `let` 키워드로 선언하기
- `const` 키워드로 선언하기
- 키워드 없이 선언하기



#### `var` 키워드로 선언하기

```javascript
var x;
```

- **`var` 키워드**로 선언된 변수는 **함수 레벨 스코프(function-level scope)**를 가진다. 즉, 함수에 지역적인 변수와 전역 변수를 선언하는데 사용한다.
- `var` 키워드로 선언한 변수는 재선언과 재할당이 가능하다.

```
var x;
var x;
```



#### `let` 키워드로 선언하기

```js
let y;
```

- ES6에 도입된 **`let` 키워드**로 선언된 변수는 **블록 레벨 스코프(block-level scope)**를 가진다. 즉, 코드 블록에 지역적인 변수를 선언하는데 사용한다.
- `let` 키워드로 선언한 변수는 재선언하면 `SyntaxError`를 발생시킨다.

```javascript
let a;
let a;	// SyntaxError: Identifier 'a' has already been declared
```



#### `const` 키워드로 선언하기

```js
const z = 1;
```

- ES6에 도입된 **`const` 키워드**로 선언된 변수는 **블록 레벨 스코프**를 가진다. `let`과 달리 상수를 만드는 데 사용한다. [3.3 상수](#32-상수)를 참고한다.
- `const` 키워드로 선언한 변수는 재선언하면 `SyntaxError`를 발생시킨다.

```javascript
const a = 1;
const a = 1;	// SyntaxError: Identifier 'a' has already been declared
```

- `const` 키워드로 선언한 변수는 재할당하면 `TypeError`를 발생시킨다.

```javascript
const a = 1;
a = 1;		// TypeError: Assignment to constant variable.
```



#### 키워드를 사용하지 않고 선언하기

```js
i;	// ReferenceError: i is not defined
```

키워드 없이 선언만 하면 선언되지 않은 전역 변수를 만든다.

```js
i = 3;
```

선언하지 않은 변수에 값을 할당하는 것을 암묵적 전역이라 한다.



#### 변수 여러 개를 선언하기

```javascript
let name, age;
```



### 선언 단계

> **선언 단계**: 변수 이름을 실행 컨텍스트(execution context)에 등록하여 자바스크립트 엔진에게 변수의 존재를 알린다.

`var`/`let`/`const`로 선언한 변수의 선언 단계가 실행되는 시점은 런타임 이전이다. [변수 선언의 실행 시점](#변수-선언의-실행-시점)과 [변수 호이스팅](#변수-호이스팅)을 참고한다.



### 초기화 단계

> **초기화 단계**: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 `undefined`를 할당하여 초기화한다.

`var`로 선언한 변수의 초기화 단계가 실행되는 시점은 런타임 이전이다. `let`/`const`로 선언한 변수의 초기화 단계가 실행되는 시점은 런타임 이후이다. 초기화 단계가 실행되기 전 변수를 참조하면 `RefereneceError`를 발생시킨다.

 [변수 선언의 실행 시점](#변수-선언의-실행-시점)과 [변수 호이스팅](#변수-호이스팅)을 참고한다.



### 할당 단계(변수 할당하기)

> **할당 단계**: 값을 저장하기 위한 메모리 공간을 새롭게 확보하고 새로운 값을 할당한다.
> (초기화 단계에서 확보한 메모리 공간에 있는 `undefined`를 새로운 값으로 바꾸는 게 아니라 아예 새로운 메모리 공간을 확보하고 해당 공간에 새로운 값을 저장한다.)

변수에 값을 할당하는 방법은 두 가지가 있다.

- 변수를 선언한 후 할당하기
- 선언과 동시에 할당하기(단축 표현)



#### 변수를 선언한 후 할당하기

선언한 변수에 값을 할당하려면 할당 연산자 `=`를 사용한다.

```js
let a;
a = 1;
```

1. 선언문(`let a;`) 실행
   1. 선언 단계 실행(런타임 이전): `a`가 호이스팅되었다.
   2. 초기화 단계 실행(런타임): `a`에 `undefined`가 할당되었다.
2. 할당문(`a = 1;`) 실행
   1. 할당 단계 실행(런타임): `a`에 `1`이 할당되었다.




#### 선언과 동시에 할당하기

선언과 동시에 할당할 수 있다. 

```js
let a = 1;
```

이 단축 표현을 사용해도 자바스크립트 엔진은 [변수를 선언한 후 할당하기](#변수를-선언한-후-할당하기)처럼 두 개의 문으로 나누어 실행한다. 즉 두 소스 코드는 동일하게 변수를 선언한 후 할당하기처럼 동작한다.



#### 변수 여러 개 선언하고 할당하기

```javascript
let name = 'umi', age = 1;
```



#### 변수의 값을 다른 변수에 할당하기

자바스크립트는 변수를 다른 변수에 할당하면 **원본의 값을 복사하여 전달**한다. 이때 두 변수는 **서로 다른 메모리 공간을 가질뿐 같은 값을 저장**하게 된다.

```js
let a = 1;
let b;
b = a;
console.log(a);	// 1
console.log(b);	// 1
```

이러한 자바스크립트의 평가 전략을 **값에 의한 전달(pass by value)**라고 한다. [pass by value](#pass-by-value)를 참고한다.



### 변수 재할당하기

할당문을 사용하여 이미 선언하고 할당된 변수에 다른 값을 재할당할 수 있다.

```js
let a = 1;
a = 2;
```

이때 `1`을 할당할 때 확보한 메모리 공간에 들어있던 값 `1`을 지우고 `2`를 넣는 것이 아니라 **새롭게 메모리 공간을 확보하여 값 `2`를 넣는다.**



### 변수의 스코프

**변수의 스코프(scope)**는 변수를 참조할 수 있는 유효한 범위를 말한다. 스코프는 함수를 기준으로 나눌 수 있다.

- **전역 변수(global variable)**는 함수의 바깥에 선언된 변수이다.
- **지역 변수(local variable)**는 함수의 내부에 선언된 변수이다. 함수 내에서만 사용할 수 있다.

#### ES6 이전의 스코프

`var`로 선언된 변수는 해당 변수가 선언된 함수나 전역 범위에 지역적이다. 즉, ES6 이전에는 블록 레벨 스코프가 존재하지 않았다.

```javascript
if (true) {
    var x = 5;
}
console.log(x);	// 5
```

위 경우 `x`의 범위는  `if`문 블록이 아니라 `x`가 선언된 함수 혹은 전역 문맥이다.

#### ES6 이후의 스코프

ES6에 도입된 `let`과 `const`로 선언된 변수는 해당 변수가 선언된 블록에 지역적이다.

```javascript
if (true) {
    let y = 5;
}
console.log(y);	// ReferenceError 발생
```

[Scope](https://github.com/leegwae/study-javascript/blob/main/Scope.md)를 참고한다.



### 전역 변수

`var`로 선언한 전역 변수와 키워드 없이 선언한 변수(암묵적 전역)은 **전역 객체**(global object)의 프로퍼티가 된다. 브라우저 환경에서 전역 객체를 가리키는 식별자는 `window`이지만 전역 객체의 프로퍼티를 참조할 때에는 `window`를 생략할 수 있다.

```js
var a = 1;
window.a;	// 1
a;	// 1
```

전역 객체에 대해서는 [전역 객체](https://github.com/leegwae/study-javascript/blob/main/11.%20Objects.md#117-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4)를 참고한다.



## 3.2 상수

**상수(constant)**는 재할당이 금지된 변수로, 선언과 동시에 초기화해야한다.

- (1) 코드가 실행되기 전 그 값이 정해진 상수
- (2) 런타임 과정에서 계산되나 할당 이후 값이 변하지 않는 상수



### 상수의 선언과 할당

- ES6 `const` 키워드로 읽기 전용 상수를 선언할 수 있다. 선언과 동시에 초기화한다.

```javascript
const PI = 3.141592
```

- 상수를 런타임에 재선언하면 `SyntaxError`를 발생시킨다.

```javascript
const a = 1;
const a = 2;	// SyntaxError: Identifier 'a' has already been declared
```

- 상수를 런타임에 재할당하면 `TypeError`를 발생시킨다.

```js
const a = 1;
a = 2; // TypeError: Assignment to constant variable.
```

- 그러나 <u>상수에 할당된 객체의 프로퍼티, 배열의 내용</u>은 보호되지 않는다: **상수 객체의 값은 변하지 않지만 그 내용은 수정할 수 있다. ** 상수는 재할당이 되지 않을 뿐 값의 불변을 의미하지는 않기 때문이다.

```javascript
/* 객체의 프로퍼티 */
const MY_OBJECT = { 'name': 'lana' };
MY_OBJECT.name = 'umi';

/* 배열의 내용 */
const MY_ARRAY = [ 1, 2, 3 ];
MY_ARRAY.push(4);
```



## 변수 선언의 실행 시점

>자바스크립트 엔진은 소스코드를 평가한 후 소스코드를 한줄씩 실행한다.
>
>1. **소스코드 평가 과정**: 모든 선언문(변수 선언문, 함수 선언문 등)을 찾아내어 실행한다. 런타임 이전에 이루어진다.
>2. **소스코드 실행 과정**: 모든 선언문을 제외한 소스코드를 한줄씩 실행한다. 런타임에 이루어진다.

자바스크립트 엔진은 소스코드를 실행하기 전에(런타임 이전에) 소스코드를 평가하는데, 이때 모든 선언을 찾아 실행한다. 즉, **자바스크립트에서 선언은 런타임(runtime) 이전에 실행된다**. *선언이 상단으로 끌어올려졌다*고 하며, 이를 **호이스팅(hositing)**이라고 한다. [변수 호이스팅](#변수-호이스팅)을 참고한다.



## 변수 호이스팅

**변수 호이스팅(variable hoisting)**은 변수 선언이 상단으로 끌어올려진 것을 말한다. [Hoisting](https://github.com/leegwae/study-javascript/blob/main/Hoisting.md)을 참고한다.

#### 키워드 `var`로 선언한 경우

[변수 할당하기](#변수-할당하기)에서 볼 수 있듯이, 할당문 `var a = 1;`은 아래처럼 두 개의 문으로 나눌 수 있다.

```js
console.log(a);		// undefined

var a;
a = 1;

console.log(a);		// 1
```

이 코드에서 `라인 3`의 변수 선언문인 `var a;`만 *상단으로 끌어올려져*, 런타임 이전에 식별자 `a`에 대해 선언 단계와 초기화 단계가 실행되어 `undefined`로 초기화된다.

```js
// 런타임 이전에 선언 단계, 초기화 단계 실행
console.log(a);	// undefined

var a;
a = 1;	// 1을 할당

console.log(a);	// 1
```



#### 키워드 `let`, `const`로 선언한 경우

```js
// 런타임 이전에 선언 단계만 실행
console.log(a);		// ReferenceError: a is not defined

let a;
a = 1;		// 런타임에 초기화 단계 실행 후 1로 할당

console.log(a);
```

`let`과 `const`로 선언된 변수 선언문 역시 *상단으로 끌어올려진다*. 그러나 런타임 이전에 식별자 `a`에 대해 선언 단계만 실행된다. 따라서 초기화 단계가 실행되지 않아 `undefined`로 초기화되지 않고, `ReferenceError`를 발생시킨다.



#### 일시적 사각지대(TDZ)

`var` 키워드로 선언된 변수는 호이스팅되어 런타임 이전에 선언 단계와 초기화 단계가 실행된다. 따라서 선언 이전에 참조한 변수는 `undefined`를 반환한다.

```js
// 호이스팅되어 런타임 이전에 선언 단계, 초기화 단계 실행
console.log(a);	// undefined
var a;
```

`let`이나 `const` 키워드로 선언된 변수는 호이스팅되어 런타임 이전에 선언 단계를 실행한다. 초기화 단계는 변수 선언문에서 실행된다.

```js
// 호이스팅되어 런타임 이전에 선언 단계 실행
console.log(b);	// ReferenceError: b is not defined
let b;
```

```javascript
let b = 1;
{
    // 호이스팅되어 런타임 이전에 선언 단계 실행
    console.log(b);	// // ReferenceError: Cannot access 'b' before initialization
    let b = 2;
}
```

이처럼 변수를 스코프의 시작 지점부터 초기화 단계의 시작 지점까지 참조할 수 없는 구간을 **일시적 사각지대**(TDZ; temporal dead zone)이라고 한다.



## 네이밍 컨밴션

- 변수나 함수는 대개 카멜 케이스를 사용한다. 예) `getClassName`
- 생성자 함수, 클래스에는 파스칼 케이스를 사용한다. 예) `MyClass`
- 상수는 대개 대문자와 밑줄로 구성한다. 예) `MAX_SIZE`
  - 런타임에 계산되는 경우는 변수와 동일하게 짓는다.



### 식별자 네이밍 컨밴션

- JavaScript 식별자는 문자, 밑줄, 달러 기호로 시작할 수 있다.
- JavaScript 식별자는 대소문자를 구분한다.
- JavaScript 식별자는 문자, 숫자, 밑줄을 포함할 수 있다.
- JavaScript 식별자에는 유니코드 문자, 유니코드 이스케이프 시퀀스를 사용할 수 있다.
- JavaScript 식별자에는 공백을 포함할 수 없다.
- JavaScript 식별자에는 예약어를 사용할 수 없다. (strict mode)



## let, var, const의 비교

- `var`: 함수 레벨 지역 변수 혹은 전역 변수를 선언한다.
- `let`: 블록 레벨 지역 변수를 선언한다.
- `const`: 블록 레벨 읽기 전용 상수를 선언한다.



| 키워드  | 재선언 | 재할당 |
| ------- | ------ | ------ |
| `var`   | o      | o      |
| `let`   | x      | o      |
| `const` | x      | x      |

이때 재선언이란 같은 스코프 내에서의 재선언을 의미한다. 스코프가 다르다면 이름이 같은 변수를 선언할 수 있다.

```js
const a = 1;	// 전역
{
    const a = 1;	// 코드 블록에 지역적
}
```



## Pass by Value

자바스크립트는 평가 전략으로 **값에 의한 전달(pass by value)**을 사용한다. 함수에 인자를 넘기는 관점에서는 **값에 의한 호출(call by value)**이라고 한다. 값에 의한 전달에서는 변수를 다른 변수에 할당할 때 **원본 변수의 값을 복사하여 전달**한다. 엄밀히 하면, 값에 의한 전달은 메모리 주소를 전달하고 전달받은 메모리 주소에 접근하여 값을 참조한다.



### 원시 값 전달하기

- 원시 값을 변수에 할당하면 확보된 메모리 공간에는 실제 **원시 값**이 저장된다.

```js
let a = 1;
```

변수 `a`에 원시 값 `1`을 할당할 때, 확보한 메모리 공간에는 실제로 `1`이 들어있다.

- 그렇다면 원시 값이 할당된 변수를 다른 변수에 할당하면 값에 의한 전달에 의해 원시 값이 복사되어 전달된다.

```js
let b = a;
console.log(a === b);	// true
```

변수 `b`에는 변수 `a`의 값 `1`이 복사되어 전달되었다. 즉, 변수 `b`의 메모리 공간에 변수 `a`의 메모리 공간에서 복사한 값 `1`이 저장되었다. 둘은 별개의 메모리 공간일뿐 동일한 값이 저장되어있다. 따라서, `b`의 값을 수정해도 `a`에는 변화가 없다.

````js
b = 2;
console.log(a);	// 1
console.log(b);	// 2
````



### 객체 전달하기

- 객체를 변수에 할당하면 확보된 메모리 공간에는 **참조 값**이 저장된다. 참조 값이란, 객체가 저장된 메모리 공간의 메모리 주소이다. 즉 원시 값이 그대로 저장되었던 것과 달리 실제 객체가 저장된 메모리는 따로 있고 변수에는 그 메모리의 주소(참조)가 저장되는 것이다.

```js
let foo = { name: 'lana' };
```

변수 `foo`에 객체 `{ name: 'lana' }`를 할당할 때, 확보한 메모리 공간에는 `{ name: 'lana' }`이 저장된 메모리 공간의 주소 곧 객체에 대한 참조 값이 들어있다.

- 그렇다면 객체가 할당된 변수를 다른 변수에 할당하면 값에 의한 전달에 의해 참조 값이 복사되어 전달된다.

```js
let bar = foo;
console.log(foo === bar);	// true
```

변수 `bar`에는 변수 `foo`의 객체 참조 값이 복사되어 전달되었다. 즉, 변수 `bar`의 메모리 공간에 변수 `foo`의 메모리 공간에서 복사한 참조 값이 저장되었다. 둘은 별개의 메모리 공간일뿐 동일한 값이 저장되어있다. 따라서 `bar`의 값을 수정해도 `foo`에는 변화가 없다.

```js
bar = {};
console.log(b);	// {}
console.log(a === b);	// false
```

`bar`에 `{}`를 할당하여, `bar`의 메모리 공간에는 이제 `{}`이 저장된 메모리 공간에 대한 참조가 들어있다.

- 단, 프로퍼티에 접근하면 원본 변수에도 영향을 끼친다.

```js
let foo = { name: 'lana' };
let bar = foo;
console.log(foo.name);	// 'lana'
console.log(bar.name);	// 'lana'
console.log(foo === bar);	// true
```

`foo`를 `bar`에 할당했다. `foo`와 `bar`은 동일한 객체에 대한 참조 값을 가진다. 즉, `foo`와 `bar`은 동일한 객체를 참조한다.

```js
bar.name = 'lux';
console.log(foo.name);	// 'lux'
console.log(bar.name);	// 'lux'
console.log(foo === bar);	// true
```

`bar.name`을 통해 프로퍼티에 접근하여 값을 `'lux'`로 수정했다. 프로퍼티에 접근하는 것은 변수가 참조하고 있는 객체에 직접 접근하는 것이다. 따라서 `bar`이 참조하고 있는 객체를 수정했으므로 동일한 객체를 참조하고 있는 `foo`의 `name` 프로퍼티도 `'lux'`로 출력되는 것이다.

`foo.name`을 통해 프로퍼티에 접근하여 값을 `'lux'`로 수정했어도 동일한 결과가 출력되었을 것이다.

```js
bar = { name: 'lux' };
console.log(foo.name);	// 'lana'
console.log(bar.name);	// 'lux'
console.log(foo === bar);	// false
```

만약 `bar.name`을 수정하지 않고 `bar`에 새롭게 객체를 할당했다면, 자바스크립트 엔진은 객체 리터럴을 평가하여 새로운 메모리 공간을 할당하고 그에 대한 참조를 `bar`의 변수가 확보한 메모리 공간에 저장했을 것이다.이렇게 하면 `foo`와 `bar`은 더이상 같은 객체를 참조하지 않으므로 일치 비교 연산에서 `false`를 반환한다.



### pass by sharing

자바스크립트는 값에 의한 전달을 사용하므로 변수를 다른 변수에 할당하면 원본 변수의 값이 복사되어 전달된다. 한편, 원시 값을 변수에 할당하면 확보한 메모리 공간에는 해당 원시 값이 저장된다. 반면에 객체를 변수에 할당하면 확보한 메모리 공간에는 객체에 대한 참조 값이 저장된다.

변수에 원시 값을 할당했든 객체를 할당했든 값에 의한 전달을 사용한다는 점에서는 동일하다. 다만 *값을 수정*한다는 관점에서, 원시 값의 경우 원본 변수는 영향을 받지 않지만 객체의 경우 원본 변수가 영향을 받는다는 차이가 있다. 따라서 의미를 더 명확히 하기 위해 **공유에 의한 전달(pass by sharing)** 혹은 **공유에 의한 호출(call by sharing)**이라고도 한다.

인자를 함수에 전달할 때 함수의 매개변수에 인자가 복사되는 관점에서 살펴보려면 [Call by Sharing](https://github.com/leegwae/study-javascript/blob/main/Call%20by%20Sharing.md)을 참고한다.



## 참고

- 모던 자바스크립트 Deep Dive 4장 변수
- 모던 자바스크립트 Deep Dive 15장 let, const 키워드와 블록 레벨 스코프
- [TDZ을 모른 채 자바스크립트 변수를 사용하지 말라](https://ui.toast.com/weekly-pick/ko_20191014)



## 스터디

### 호이스팅이란 무엇인가?

호이스팅은 선언이 자신이 속한 스코프의 최상단으로 끌어올려지는 것을 말한다.

```javascript
console.log(score);

score = 80;
var score;

console.log(score);
```

- **코드에서 출력되는 값과 그 이유는?** `undefined`와 `80`이 차례로 출력된다. `var`로 선언한 변수 `score`는 호이스팅되어 전역 스코프의 가장 상단으로 끌어올려지고, `undefined`로 초기화가 이루어진다. 따라서 새로운 값을 할당하기 전까지는 `undefined`를, 할당 이후 `80`이라는 값을 가진다.



### `let`으로 선언한 변수는 호이스팅되는가?

호이스팅된다.

```javascript
let b = 1;
{
    console.log(b);
    let b = 2;
}
```

- **코드에서 출력되는 값과 그 이유는?** ReferenceError(Cannot access 'b' before initialization)가 발생한다. `let`으로 선언한 변수 `b`는 호이스팅되어 블록 내에서 가장 상단으로 끌여올려지나, 초기화가 이루어지기 전까지는 접근할 수 없는 변수가 된다.



### `var`, `let`, `const` 차이점에 대해 설명하라

`var`로 선언한 변수는 재선언, 재할당이 가능하며 함수 레벨 스코프를 가진다. `const`와 `let`으로 선언한 변수는 블록 레벨 스코프를 가지는데, `let`은 재선언은 불가능하지만 재할당은 가능하다. `const`는 재선언과 재할당이 불가능하다. 세 경우에서 변수는 모두 호이스팅되나 `let`과 `const`는 초기화 이전에 접근하면 ReferenceError를 발생시키고 `var`로 선언한 변수는 `undefined`로 접근된다.



### 변수에 값을 할당하는 과정에 대해 설명하라

다음과 같이 변수 `result`를 선언과 동시에 초기화한다고 하자.

```javascript
var result = 10;
```

자바스크립트 엔진은 런타임 이전에 선언을 실행한 후, 새로운 메모리 공간을 확보하고 `undefined`로 초기화한다. 런타임에 할당문을 실행하면 기존의 공간이 아니라 새로운 메모리 공간을 확보하고 `10`을 저장한다.
